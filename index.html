<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chi<span style="text-shadow: 0 3px 2px red;">naza</span> Uzoukwu</title>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&display=swap" rel="stylesheet">
    <link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
  crossorigin="anonymous"
  referrerpolicy="no-referrer"
/>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111111; }
        canvas { display: block; }
        #export-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 100;
        }
        #export-btn:hover {
            background: #0052a3;
        }
        #text-overlay {
            position: absolute;
            top: 50%;
            left: 0;
            width: 50%;
            transform: translateY(-50%);
            color: white;
            font-family: Georgia, 'Times New Roman', serif;
            z-index: 100;
            line-height: 1.6;
            text-align: center;
            padding: 0 40px;
            box-sizing: border-box;
            
            font-family: "Cormorant Garamond", "Times New Roman", serif;
  
  line-height: 0.9;
        }
        
        #text-overlay h1 {
            margin: 0 0 30px 0;
            font-size: 70px;
            font-weight: normal;
        }
        #text-overlay p {
            margin: 0;
            font-size: 35px;
        }

         .socials a {
    color: #ccc;
    margin: 0 8px;
    font-size: 1.5em;
    transition: color 0.2s;
  }
  .socials a:hover {
    color: #fff;
  }
    </style>
</head>
<body>
<button id="export-btn">Export Camera</button>
<div id="text-overlay">
    <h1>Chi<span style="text-shadow: 6px 6px 1px #aa0000;">naza</span> Uzoukwu</h1>
    <p>Welcome to my corner of the web</p>
    <br><br>
    <div class="socials">
        <a href="https://twitter.com/zoukwuberg" target="_blank"><i class="fab fa-x-twitter"></i></a>
        <a href="https://github.com/nassir90" target="_blank"><i class="fab fa-github"></i></a>
        <a href="https://www.linkedin.com/in/chinaza-uzoukwu-a33219228" target="_blank"><i class="fab fa-linkedin"></i></a>
        <a href="https://www.youtube.com/@ChinazaUzoukwu/"><i class="fa-brands fa-youtube"></i></a>
      </div>
</div>
<div>
    
</div>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Debug mode - set to true to show export button
const DEBUG_MODE = false;

// Dropout parameter - percentage of points to render (0.0 to 1.0)
const DROPOUT_RATE = 1.0; // 10% of points will be rendered

// Camera configuration - modify these values to set initial view
const cameraConfig = {
  "position": {
    "x": -0.16460022675053126,
    "y": -0.6228621995655184,
    "z": 2.2373369015612683
  },
  "target": {
    "x": -0.24632319124295435,
    "y": 0.8274498897248066,
    "z": 0.6926157919499376
  },
  "fov": 75
};

async function loadPointsBin(url) {
  const res = await fetch(url);
  const buffer = await res.arrayBuffer();
  const floats = new Float32Array(buffer);

  const points = [];
  for (let i = 0; i < floats.length; i += 3) {
    points.push({ x: floats[i], y: floats[i + 1], z: floats[i + 2] });
  }

  return points;
}

async function loadPointCloud() {
    const data = await loadPointsBin('pointcloud_capture.bin');
    return data;
}

function createPointCloud(points) {
    const geometry = new THREE.BufferGeometry();
    
    // Apply distance filter and dropout sampling
    const filteredPoints = points.filter(p => {
        const distance = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
        if (distance > 2.0) return false;
        
        // Apply dropout - randomly keep only DROPOUT_RATE percentage of points
        return Math.random() < DROPOUT_RATE;
    });
    
    const positions = new Float32Array(filteredPoints.length * 3);
    const originalPositions = new Float32Array(filteredPoints.length * 3);
    
    for (let i = 0; i < filteredPoints.length; i++) {
        positions[3*i] = filteredPoints[i].x;
        positions[3*i + 1] = filteredPoints[i].y;
        positions[3*i + 2] = filteredPoints[i].z;
        
        // Store original positions for distortion calculations
        originalPositions[3*i] = filteredPoints[i].x;
        originalPositions[3*i + 1] = filteredPoints[i].y;
        originalPositions[3*i + 2] = filteredPoints[i].z;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.userData.originalPositions = originalPositions;

    const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.0015 });
    return new THREE.Points(geometry, material);
}

async function main() {
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(cameraConfig.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(cameraConfig.position.x, cameraConfig.position.y, cameraConfig.position.z);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(cameraConfig.target.x, cameraConfig.target.y, cameraConfig.target.z);
    controls.enabled = DEBUG_MODE; // Only enable controls in debug mode
    controls.update();

    const points = await loadPointCloud();
    const pointCloud = createPointCloud(points);
    scene.add(pointCloud);
    
    // Mouse interaction setup
    const raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 0.05; // Detection radius
    const mouse = new THREE.Vector2();
    let mouseWorldPos = new THREE.Vector3();
    let windIntensity = 0; // 0 to 1, controls wind effect strength
    let lastMouseMoveTime = 0;
    const windFadeInDuration = 1000; // 1 second to fade in
    const windFadeOutDelay = 2000; // 2 seconds of inactivity before fade out
    const windFadeOutDuration = 1500; // 1.5 seconds to fade out
    
    // Mouse move handler with throttling
    let lastRaycastTime = 0;
    const raycastThrottle = 16; // ~60fps, only raycast every 16ms
    
    function onMouseMove(event) {
        const now = Date.now();
        lastMouseMoveTime = now;
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Throttle raycasting for performance
        if (now - lastRaycastTime > raycastThrottle) {
            lastRaycastTime = now;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Get intersection point in 3D space
            const intersects = raycaster.intersectObject(pointCloud);
            if (intersects.length > 0) {
                mouseWorldPos.copy(intersects[0].point);
            }
        }
    }
    
    window.addEventListener('mousemove', onMouseMove, { passive: true });
    
    // Distortion function
    let time = 0;
    let windStartTime = 0;
    let isFadingIn = false;
    
    // Pre-calculate sine lookup table for flutter (major performance boost)
    const FLUTTER_TABLE_SIZE = 1024;
    const flutterTable1 = new Float32Array(FLUTTER_TABLE_SIZE);
    const flutterTable2 = new Float32Array(FLUTTER_TABLE_SIZE);
    const flutterTable3 = new Float32Array(FLUTTER_TABLE_SIZE);
    for (let i = 0; i < FLUTTER_TABLE_SIZE; i++) {
        const angle = (i / FLUTTER_TABLE_SIZE) * Math.PI * 2;
        flutterTable1[i] = Math.sin(angle) * 0.003;
        flutterTable2[i] = Math.sin(angle) * 0.002;
        flutterTable3[i] = Math.sin(angle) * 0.0025;
    }
    
    function applyDistortion() {
        const now = Date.now();
        const timeSinceLastMove = now - lastMouseMoveTime;
        
        // Update wind intensity with easing
        if (timeSinceLastMove < windFadeOutDelay) {
            // Mouse is active, fade in
            if (!isFadingIn) {
                windStartTime = now;
                isFadingIn = true;
            }
            const fadeInProgress = Math.min((now - windStartTime) / windFadeInDuration, 1);
            windIntensity = fadeInProgress * fadeInProgress * (3 - 2 * fadeInProgress); // Smoothstep
        } else {
            // Mouse inactive, fade out
            isFadingIn = false;
            const fadeOutProgress = Math.min((timeSinceLastMove - windFadeOutDelay) / windFadeOutDuration, 1);
            const fadeOutEased = fadeOutProgress * fadeOutProgress * (3 - 2 * fadeOutProgress); // Smoothstep
            windIntensity = 1 - fadeOutEased;
        }
        
        // Skip processing if wind is completely off
        if (windIntensity <= 0.001) {
            windIntensity = 0;
            return;
        }
        
        time += 0.016; // Approximate frame time
        const positions = pointCloud.geometry.attributes.position.array;
        const originalPositions = pointCloud.geometry.userData.originalPositions;
        const distortionRadius = 0.35; // Radius of effect
        const distortionRadiusSq = distortionRadius * distortionRadius; // Squared for faster comparison
        const distortionStrength = 0.05; // How much to push points
        const invDistortionRadius = 1 / distortionRadius;
        
        // Pre-calculate lookup table indices
        const tableIndex1 = ((time * 2.5) % (Math.PI * 2)) / (Math.PI * 2) * FLUTTER_TABLE_SIZE;
        const tableIndex2 = ((time * 3.2) % (Math.PI * 2)) / (Math.PI * 2) * FLUTTER_TABLE_SIZE;
        const tableIndex3 = ((time * 1.8) % (Math.PI * 2)) / (Math.PI * 2) * FLUTTER_TABLE_SIZE;
        
        // Cache mouse position
        const mouseX = mouseWorldPos.x;
        const mouseY = mouseWorldPos.y;
        const mouseZ = mouseWorldPos.z;
        
        const numPoints = positions.length / 3;
        
        for (let i = 0; i < positions.length; i += 3) {
            const originalX = originalPositions[i];
            const originalY = originalPositions[i + 1];
            const originalZ = originalPositions[i + 2];
            
            // Calculate distance from mouse position (squared for performance)
            const dx = originalX - mouseX;
            const dy = originalY - mouseY;
            const dz = originalZ - mouseZ;
            const distanceSq = dx * dx + dy * dy + dz * dz;
            
            // Use lookup table for flutter (much faster than Math.sin)
            const pointIndex = (i / 3) / numPoints;
            const idx1 = ((tableIndex1 + pointIndex * 102.4) | 0) % FLUTTER_TABLE_SIZE;
            const idx2 = ((tableIndex2 + pointIndex * 153.6) | 0) % FLUTTER_TABLE_SIZE;
            const idx3 = ((tableIndex3 + pointIndex * 81.92) | 0) % FLUTTER_TABLE_SIZE;
            
            const flutterAmount = (flutterTable1[idx1] + flutterTable2[idx2] + flutterTable3[idx3]) * windIntensity;
            
            if (distanceSq < distortionRadiusSq) {
                // Apply gentle, gradual falloff with cubic easing
                const distance = Math.sqrt(distanceSq);
                const influence = 1 - distance * invDistortionRadius;
                const easedInfluence = influence * influence * influence; // Cubic ease for gentler start
                
                // Push points away from mouse
                const pushAmount = distortionStrength * easedInfluence;
                const invDistance = 1 / (distance + 0.0001);
                const dirX = dx * invDistance;
                const dirY = dy * invDistance;
                const dirZ = dz * invDistance;
                
                positions[i] = originalX + dirX * pushAmount + flutterAmount;
                positions[i + 1] = originalY + dirY * pushAmount + flutterAmount * 0.8;
                positions[i + 2] = originalZ + dirZ * pushAmount + flutterAmount * 1.2;
            } else {
                // Apply only flutter effect
                positions[i] = originalX + flutterAmount;
                positions[i + 1] = originalY + flutterAmount * 0.8;
                positions[i + 2] = originalZ + flutterAmount * 1.2;
            }
        }
        
        pointCloud.geometry.attributes.position.needsUpdate = true;
    }

    // Show/hide export button based on debug mode
    const exportBtn = document.getElementById('export-btn');
    if (!DEBUG_MODE) {
        exportBtn.style.display = 'none';
    }

    // Export camera button handler
    exportBtn.addEventListener('click', () => {
        const config = {
            position: {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            },
            target: {
                x: controls.target.x,
                y: controls.target.y,
                z: controls.target.z
            },
            fov: camera.fov
        };
        
        const json = JSON.stringify(config, null, 2);
        console.log('Camera Configuration:');
        console.log(json);
        
        // Copy to clipboard
        navigator.clipboard.writeText(json).then(() => {
            alert('Camera parameters copied to clipboard!');
        }).catch(err => {
            alert('Camera parameters logged to console');
        });
    });

    // Run animation at 10Hz for performance
    const animationInterval = 75; // 100ms = 10Hz
    
    function animate() {
    renderer.setSize(window.innerWidth, window.innerHeight);
        controls.update();
        applyDistortion();
        renderer.render(scene, camera);
    }

    // Use setInterval instead of requestAnimationFrame for 10Hz
    setInterval(animate, animationInterval);
}

main();
</script>
</body>
</html>
